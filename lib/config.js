"use strict";
exports.defaults = function() {
  return {
    requireBuildAutoModule: {
      patterns: ["**/*.js"],
      exclude: [/-built.js$/, /reload-client.js$/],
      dontBuild: ["specs"],
      plugins: [
        {
          path: "vendor/requirejs-text/text",
          patterns: ["**/*.html"]
        }
      ],
      modules: [
        {
          name: "app/app-built",
          baseUrl: "app",
          include: [],
          patterns: [],
          exclude: [],
          versionOf: ""
        }
      ]
    }
  };
};

exports.placeholder = function() {
  return "\t\n\n  # requireBuildAutoModule:\n    # patterns: []                     # Patterns to match files for inclusion. By default,\n                                       # this matches all javascript files. An alternative\n                                       # is to have this only match your main.js file, and\n                                       # let r.js detect and include any required dependencies\n\n    # exclude: []                      # A list of regexes or strings used to prevent the\n                                       # inclusion of matching files.\n\n    # dontBuild: []                    # A list patterns used to prevent building matched folders\n                                       # into modules. The module configs are still generated \n                                       # for use if the excluded modules are included in another\n                                       # module. By default this excludes spec directories.\n\n    # plugins: [{                      # An array of plugin configs. This allows you to load\n                                       # specific files using requirejs plugins. An example is\n                                       # the text plugin for loading html files.\n\n    #   path: \"\"                       # The path to the plugin to be used. Should be relative\n                                       # to the javascriptsDir. If the file is aliased in your \n                                       # requirejs config, the alias will be used instead.\n\n    #   patterns: []                   # Patterns to match files to be loaded using this plugin.\n                                       # Any files matched for a specific plugin will only be\n                                       # included using that plugin.\n    # }]\n\n    # modules: [{                      # The modules list is dynamically built, but you can\n                                       # add module configs here to override default behaviour.\n                                       # The entries that are automatically added are named as\n                                       # \"folderName/folderName-built\"\n\n    #   name: \"\"                       # Name of the module. If the name matches that of a\n                                       # module specified in the r.js config, that config is\n                                       # augmented using the values generated by this plugin.\n                                       # Otherwise, it creates a new module config that it injects \n                                       # in the r.js config.\n\n    #   baseUrl: \"\"                    # The baseUrl is automatically detected by the plugin,\n                                       # but this allows you to override it if you are setting up\n                                       # up a custom config for this module. The baseUrl is also\n                                       # used to make sure that duplicate modules aren't created\n                                       # for the same folder.\n\n    #   include: []                    # An array of strings used to find other modules to build\n                                       # into this module. Will try to match name or baseUrl.\n\n    #   patterns: []                   # Patterns to match files for inclusion. If not specified\n                                       # here, uses the patterns specified above. Must be\n                                       # specified here or above.\n\n    #   exclude: []                    # List of regexes or strings to prevent files from\n                                       # being included. If not specified here, uses the exclude\n                                       # specified above. Must be specified here or above.\n\n    #   plugins: [{                    # This allows you to specify a differnet set of plugin\n                                       # configs for this specific module. Each config should\n                                       # have a path and a patterns array specified.\n    #   }]\n\n    #   versionOf: \"\"                  # A string used to match the baseUrl or name of another\n                                       # module. If a match is found, this module is built by\n                                       # aliasing all of it's files to the baseUrl of the matched\n                                       # module. If you have a scenario like:\n                                       # moduleC is a version of moduleB is a version of moduleA\n                                       # Then, moduleC's files are aliased to the baseUrl of moduleA\n\n    #   includeAliasedFiles: true      # If true, adds the aliased files to the module's include \n                                       # array, causing them to be built into the final module.\n    # }]";
};

exports.validate = function(config, validators) {
  var errors, moduleConfig, pluginConfig, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
  errors = [];
  if (validators.ifExistsIsObject(errors, "requireBuildAutoModule config", config.requireBuildAutoModule)) {
    validators.ifExistsIsArrayOfStrings(errors, "requireBuildAutoModule.patterns", config.requireBuildAutoModule.patterns);
    validators.ifExistsFileExcludeWithRegexAndString(errors, "requireBuildAutoModule.exclude", config.requireBuildAutoModule, config.watch.compiledDir);
    validators.ifExistsIsArrayOfStrings(errors, "requireBuildAutoModule.dontBuild", config.requireBuildAutoModule.dontBuild);
    if (validators.ifExistsIsArrayOfObjects(errors, "requireBuildAutoModule.plugins", config.requireBuildAutoModule.plugins)) {
      _ref = config.requireBuildAutoModule.plugins;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pluginConfig = _ref[_i];
        validators.stringMustExist(errors, "requireBuildAutoModule.plugins.path", pluginConfig.path);
        validators.isArrayOfStringsMustExist(errors, "requireBuildAutoModule.plugins.patterns", pluginConfig.patterns);
      }
    }
    if (validators.ifExistsIsArrayOfObjects(errors, "requireBuildAutoModule.modules", config.requireBuildAutoModule.modules)) {
      _ref1 = config.requireBuildAutoModule.modules;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        moduleConfig = _ref1[_j];
        validators.stringMustExist(errors, "requireBuildAutoModule.modules.name", moduleConfig.name);
        validators.ifExistsIsString(errors, "requireBuildAutoModule.modules.baseUrl", moduleConfig.baseUrl);
        validators.ifExistsIsArrayOfStrings(errors, "requireBuildAutoModule.modules.include", moduleConfig.include);
        if (!validators.ifExistsIsArrayOfStrings(errors, "requireBuildAutoModule.modules.patterns", moduleConfig.patterns)) {
          if (validators.isArrayOfStringsMustExist(errors, "requireBuildAutoModule.patterns", config.requireBuildAutoModule.patterns)) {
            moduleConfig.patterns = config.requireBuildAutoModule.patterns;
          }
        }
        if (!validators.ifExistsFileExcludeWithRegexAndString(errors, "requireBuildAutoModule.modules.exclude", moduleConfig, config.watch.compiledDir)) {
          moduleConfig.exclude = config.requireBuildAutoModule.exclude;
        }
        if (validators.ifExistsIsArrayOfObjects(errors, "requireBuildAutoModule.modules.plugins", moduleConfig.plugins)) {
          _ref2 = moduleConfig.plugins;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            pluginConfig = _ref2[_k];
            validators.stringMustExist(errors, "requireBuildAutoModule.modules.plugins.path", pluginConfig.path);
            validators.isArrayOfStringsMustExist(errors, "requireBuildAutoModule.modules.plugins.patterns", pluginConfig.patterns);
          }
        } else {
          moduleConfig.plugins = config.requireBuildAutoModule.plugins;
        }
        validators.ifExistsIsString(errors, "requireBuildAutoModule.modules.versionOf", moduleConfig.versionOf);
        if (!validators.ifExistsIsBoolean(errors, "requireBuildAutoModule.modules.includeAliasedFiles", moduleConfig.includeAliasedFiles)) {
          moduleConfig.includeAliasedFiles = true;
        }
      }
    }
  }
  return errors;
};

//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQzpcXHByb2plY3RzXFxtaW1vc2EtbW9kdWxlc1xcbWltb3NhLXJlcXVpcmVidWlsZC1hdXRvbW9kdWxlXFxsaWJcXGNvbmZpZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkM6XFxwcm9qZWN0c1xcbWltb3NhLW1vZHVsZXNcXG1pbW9zYS1yZXF1aXJlYnVpbGQtYXV0b21vZHVsZVxcc3JjXFxjb25maWcuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLENBQUEsV0FBQTtBQUVBLENBRkEsRUFFbUIsSUFBWixDQUFQLENBQW1CO1NBQ2pCO0NBQUEsQ0FDRSxFQURGLGtCQUFBO0NBQ0UsQ0FBVSxJQUFWLEVBQUEsQ0FBVTtDQUFWLENBQ1MsSUFBVCxDQUFBLEtBQVMsT0FBQTtDQURULENBRVcsSUFBWCxDQUFXLEVBQVg7Q0FGQSxDQUdTLElBQVQsQ0FBQTtTQUFVO0NBQUEsQ0FDRixFQUFOLE1BQUEsa0JBRFE7Q0FBQSxDQUVFLE1BQVYsRUFBQSxDQUFVO1VBRkg7UUFIVDtDQUFBLENBT1MsSUFBVCxDQUFBO1NBQVU7Q0FBQSxDQUNGLEVBQU4sTUFBQSxLQURRO0NBQUEsQ0FFQyxHQUZELEVBRVIsR0FBQTtDQUZRLENBR0MsS0FBVCxHQUFBO0NBSFEsQ0FJRSxNQUFWLEVBQUE7Q0FKUSxDQUtDLEtBQVQsR0FBQTtDQUxRLENBTUcsT0FBWCxDQUFBO1VBTk87UUFQVDtNQURGO0NBRGlCO0NBQUE7O0FBa0JuQixDQXBCQSxFQW9Cc0IsSUFBZixFQUFlLEVBQXRCO0NBQXNCLFFBQ3BCO0NBRG9COztBQTRFdEIsQ0FoR0EsQ0FnRzRCLENBQVQsR0FBQSxDQUFaLENBQVAsQ0FBb0IsQ0FBRDtDQUNqQixLQUFBLGdGQUFBO0NBQUEsQ0FBQSxDQUFTLEdBQVQ7Q0FDQSxDQUFBLEVBQUcsRUFBQSxJQUFVLE1BQVYsTUFBQSxTQUFBO0NBQ0QsQ0FBNEMsRUFBNUMsRUFBQSxFQUFBLEVBQVUsWUFBa0csRUFBNUcsU0FBQTtDQUFBLENBQ3lELEVBQXpELENBQXNJLENBQXRJLElBQVUsQ0FBVixXQUFBLFVBQUEsS0FBQTtDQURBLENBRTRDLEVBQTVDLEVBQUEsR0FBQSxDQUFVLFlBQW1HLEVBQTdHLFVBQUE7Q0FDQSxDQUErQyxFQUEvQyxFQUFHLENBQUEsR0FBVSxZQUFpRyxFQUEzRyxRQUFBO0NBQ0Q7Q0FBQSxVQUFBLGdDQUFBO2lDQUFBO0NBQ0UsQ0FBbUMsRUFBbkMsRUFBQSxFQUFBLEVBQVUsRUFBNEUsR0FBdEYsc0JBQUE7Q0FBQSxDQUM2QyxJQUE3QyxFQUFBLEVBQVUsRUFBMEYsYUFBcEcsZ0JBQUE7Q0FGRixNQURGO01BSEE7Q0FPQSxDQUErQyxFQUEvQyxFQUFHLENBQUEsR0FBVSxZQUFpRyxFQUEzRyxRQUFBO0NBQ0Q7Q0FBQSxVQUFBLG1DQUFBO2tDQUFBO0NBQ0UsQ0FBbUMsRUFBbkMsRUFBQSxFQUFBLEVBQVUsRUFBNEUsR0FBdEYsc0JBQUE7Q0FBQSxDQUNvQyxJQUFwQyxDQUFBLENBQUEsRUFBVSxFQUFnRixJQUExRix3QkFBQTtDQURBLENBRTRDLElBQTVDLENBQUEsQ0FBQSxFQUFVLEVBQXdGLFlBQWxHLGdCQUFBO0FBQ08sQ0FBUCxDQUFtRCxFQUFuRCxFQUFPLEVBQVAsRUFBaUIsRUFBeUYsWUFBbkcsaUJBQUE7Q0FDTCxDQUFnRCxFQUE3QyxFQUFBLEVBQUEsRUFBSCxZQUFnSCxHQUE3RyxRQUFBO0NBQ0QsRUFBd0IsR0FBTSxFQUE5QixJQUFBLFVBQXFEO1lBRnpEO1VBSEE7QUFNTyxDQUFQLENBQWdFLEVBQWhFLENBQW9JLENBQTdILEVBQVAsRUFBaUIsQ0FBVixDQUFBLHlCQUFBLEdBQUE7Q0FDTCxFQUF1QixHQUFNLENBQTdCLEdBQUEsRUFBWSxVQUF3QztVQVB0RDtDQVFBLENBQStDLEVBQTVDLEVBQUEsQ0FBQSxDQUFILEVBQWEsRUFBd0YsWUFBbEcsZ0JBQUE7Q0FDRDtDQUFBLGNBQUEsK0JBQUE7c0NBQUE7Q0FDRSxDQUFtQyxFQUFuQyxFQUFBLElBQVUsRUFBVixHQUFBLDhCQUFBO0NBQUEsQ0FDNkMsSUFBN0MsRUFBQSxFQUFVLEVBQVYsYUFBQSx3QkFBQTtDQUZGLFVBREY7TUFBQSxJQUFBO0NBS0UsRUFBdUIsR0FBTSxDQUE3QixHQUFBLEVBQVksVUFBd0M7VUFidEQ7Q0FBQSxDQWNvQyxJQUFwQyxFQUFBLENBQUEsQ0FBVSxFQUFrRixJQUE1RiwwQkFBQTtBQUNPLENBQVAsQ0FBNEMsRUFBNUMsRUFBTyxFQUFQLEVBQWlCLEVBQTZGLEtBQXZHLEVBQUEsaUNBQUE7Q0FDTCxFQUFtQyxDQUFuQyxNQUFBLEVBQVksT0FBWjtVQWpCSjtDQUFBLE1BREY7TUFSRjtJQURBO0NBRGlCLFFBOEJqQjtDQTlCaUIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxyXG5cclxuZXhwb3J0cy5kZWZhdWx0cyA9IC0+XHJcbiAgcmVxdWlyZUJ1aWxkQXV0b01vZHVsZTpcclxuICAgIHBhdHRlcm5zOiBbXCIqKi8qLmpzXCJdXHJcbiAgICBleGNsdWRlOiBbLy1idWlsdC5qcyQvLC9yZWxvYWQtY2xpZW50LmpzJC9dXHJcbiAgICBkb250QnVpbGQ6IFtcInNwZWNzXCJdXHJcbiAgICBwbHVnaW5zOiBbe1xyXG4gICAgICBwYXRoOiBcInZlbmRvci9yZXF1aXJlanMtdGV4dC90ZXh0XCJcclxuICAgICAgcGF0dGVybnM6IFtcIioqLyouaHRtbFwiXVxyXG4gICAgfV1cclxuICAgIG1vZHVsZXM6IFt7XHJcbiAgICAgIG5hbWU6IFwiYXBwL2FwcC1idWlsdFwiXHJcbiAgICAgIGJhc2VVcmw6IFwiYXBwXCJcclxuICAgICAgaW5jbHVkZTogW11cclxuICAgICAgcGF0dGVybnM6IFtdXHJcbiAgICAgIGV4Y2x1ZGU6IFtdXHJcbiAgICAgIHZlcnNpb25PZjogXCJcIlxyXG4gICAgfV1cclxuXHJcbmV4cG9ydHMucGxhY2Vob2xkZXIgPSAtPlxyXG4gIFwiXCJcIlxyXG4gIFxcdFxyXG5cclxuICAgICMgcmVxdWlyZUJ1aWxkQXV0b01vZHVsZTpcclxuICAgICAgIyBwYXR0ZXJuczogW10gICAgICAgICAgICAgICAgICAgICAjIFBhdHRlcm5zIHRvIG1hdGNoIGZpbGVzIGZvciBpbmNsdXNpb24uIEJ5IGRlZmF1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB0aGlzIG1hdGNoZXMgYWxsIGphdmFzY3JpcHQgZmlsZXMuIEFuIGFsdGVybmF0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBpcyB0byBoYXZlIHRoaXMgb25seSBtYXRjaCB5b3VyIG1haW4uanMgZmlsZSwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBsZXQgci5qcyBkZXRlY3QgYW5kIGluY2x1ZGUgYW55IHJlcXVpcmVkIGRlcGVuZGVuY2llc1xyXG5cclxuICAgICAgIyBleGNsdWRlOiBbXSAgICAgICAgICAgICAgICAgICAgICAjIEEgbGlzdCBvZiByZWdleGVzIG9yIHN0cmluZ3MgdXNlZCB0byBwcmV2ZW50IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgaW5jbHVzaW9uIG9mIG1hdGNoaW5nIGZpbGVzLlxyXG5cclxuICAgICAgIyBkb250QnVpbGQ6IFtdICAgICAgICAgICAgICAgICAgICAjIEEgbGlzdCBwYXR0ZXJucyB1c2VkIHRvIHByZXZlbnQgYnVpbGRpbmcgbWF0Y2hlZCBmb2xkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBpbnRvIG1vZHVsZXMuIFRoZSBtb2R1bGUgY29uZmlncyBhcmUgc3RpbGwgZ2VuZXJhdGVkIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgZm9yIHVzZSBpZiB0aGUgZXhjbHVkZWQgbW9kdWxlcyBhcmUgaW5jbHVkZWQgaW4gYW5vdGhlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgbW9kdWxlLiBCeSBkZWZhdWx0IHRoaXMgZXhjbHVkZXMgc3BlYyBkaXJlY3Rvcmllcy5cclxuXHJcbiAgICAgICMgcGx1Z2luczogW3sgICAgICAgICAgICAgICAgICAgICAgIyBBbiBhcnJheSBvZiBwbHVnaW4gY29uZmlncy4gVGhpcyBhbGxvd3MgeW91IHRvIGxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHNwZWNpZmljIGZpbGVzIHVzaW5nIHJlcXVpcmVqcyBwbHVnaW5zLiBBbiBleGFtcGxlIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB0aGUgdGV4dCBwbHVnaW4gZm9yIGxvYWRpbmcgaHRtbCBmaWxlcy5cclxuXHJcbiAgICAgICMgICBwYXRoOiBcIlwiICAgICAgICAgICAgICAgICAgICAgICAjIFRoZSBwYXRoIHRvIHRoZSBwbHVnaW4gdG8gYmUgdXNlZC4gU2hvdWxkIGJlIHJlbGF0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB0byB0aGUgamF2YXNjcmlwdHNEaXIuIElmIHRoZSBmaWxlIGlzIGFsaWFzZWQgaW4geW91ciBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHJlcXVpcmVqcyBjb25maWcsIHRoZSBhbGlhcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHJcbiAgICAgICMgICBwYXR0ZXJuczogW10gICAgICAgICAgICAgICAgICAgIyBQYXR0ZXJucyB0byBtYXRjaCBmaWxlcyB0byBiZSBsb2FkZWQgdXNpbmcgdGhpcyBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBBbnkgZmlsZXMgbWF0Y2hlZCBmb3IgYSBzcGVjaWZpYyBwbHVnaW4gd2lsbCBvbmx5IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBpbmNsdWRlZCB1c2luZyB0aGF0IHBsdWdpbi5cclxuICAgICAgIyB9XVxyXG5cclxuICAgICAgIyBtb2R1bGVzOiBbeyAgICAgICAgICAgICAgICAgICAgICAjIFRoZSBtb2R1bGVzIGxpc3QgaXMgZHluYW1pY2FsbHkgYnVpbHQsIGJ1dCB5b3UgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBhZGQgbW9kdWxlIGNvbmZpZ3MgaGVyZSB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW91ci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFRoZSBlbnRyaWVzIHRoYXQgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYXJlIG5hbWVkIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBcImZvbGRlck5hbWUvZm9sZGVyTmFtZS1idWlsdFwiXHJcblxyXG4gICAgICAjICAgbmFtZTogXCJcIiAgICAgICAgICAgICAgICAgICAgICAgIyBOYW1lIG9mIHRoZSBtb2R1bGUuIElmIHRoZSBuYW1lIG1hdGNoZXMgdGhhdCBvZiBhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBtb2R1bGUgc3BlY2lmaWVkIGluIHRoZSByLmpzIGNvbmZpZywgdGhhdCBjb25maWcgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGF1Z21lbnRlZCB1c2luZyB0aGUgdmFsdWVzIGdlbmVyYXRlZCBieSB0aGlzIHBsdWdpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBtb2R1bGUgY29uZmlnIHRoYXQgaXQgaW5qZWN0cyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGluIHRoZSByLmpzIGNvbmZpZy5cclxuXHJcbiAgICAgICMgICBiYXNlVXJsOiBcIlwiICAgICAgICAgICAgICAgICAgICAjIFRoZSBiYXNlVXJsIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgYnkgdGhlIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGJ1dCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgaXQgaWYgeW91IGFyZSBzZXR0aW5nIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB1cCBhIGN1c3RvbSBjb25maWcgZm9yIHRoaXMgbW9kdWxlLiBUaGUgYmFzZVVybCBpcyBhbHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IGR1cGxpY2F0ZSBtb2R1bGVzIGFyZW4ndCBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBmb3IgdGhlIHNhbWUgZm9sZGVyLlxyXG5cclxuICAgICAgIyAgIGluY2x1ZGU6IFtdICAgICAgICAgICAgICAgICAgICAjIEFuIGFycmF5IG9mIHN0cmluZ3MgdXNlZCB0byBmaW5kIG90aGVyIG1vZHVsZXMgdG8gYnVpbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGludG8gdGhpcyBtb2R1bGUuIFdpbGwgdHJ5IHRvIG1hdGNoIG5hbWUgb3IgYmFzZVVybC5cclxuXHJcbiAgICAgICMgICBwYXR0ZXJuczogW10gICAgICAgICAgICAgICAgICAgIyBQYXR0ZXJucyB0byBtYXRjaCBmaWxlcyBmb3IgaW5jbHVzaW9uLiBJZiBub3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBoZXJlLCB1c2VzIHRoZSBwYXR0ZXJucyBzcGVjaWZpZWQgYWJvdmUuIE11c3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHNwZWNpZmllZCBoZXJlIG9yIGFib3ZlLlxyXG5cclxuICAgICAgIyAgIGV4Y2x1ZGU6IFtdICAgICAgICAgICAgICAgICAgICAjIExpc3Qgb2YgcmVnZXhlcyBvciBzdHJpbmdzIHRvIHByZXZlbnQgZmlsZXMgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgYmVpbmcgaW5jbHVkZWQuIElmIG5vdCBzcGVjaWZpZWQgaGVyZSwgdXNlcyB0aGUgZXhjbHVkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgc3BlY2lmaWVkIGFib3ZlLiBNdXN0IGJlIHNwZWNpZmllZCBoZXJlIG9yIGFib3ZlLlxyXG5cclxuICAgICAgIyAgIHBsdWdpbnM6IFt7ICAgICAgICAgICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGEgZGlmZmVybmV0IHNldCBvZiBwbHVnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGNvbmZpZ3MgZm9yIHRoaXMgc3BlY2lmaWMgbW9kdWxlLiBFYWNoIGNvbmZpZyBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGhhdmUgYSBwYXRoIGFuZCBhIHBhdHRlcm5zIGFycmF5IHNwZWNpZmllZC5cclxuICAgICAgIyAgIH1dXHJcblxyXG4gICAgICAjICAgdmVyc2lvbk9mOiBcIlwiICAgICAgICAgICAgICAgICAgIyBBIHN0cmluZyB1c2VkIHRvIG1hdGNoIHRoZSBiYXNlVXJsIG9yIG5hbWUgb2YgYW5vdGhlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgbW9kdWxlLiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGlzIG1vZHVsZSBpcyBidWlsdCBieVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgYWxpYXNpbmcgYWxsIG9mIGl0J3MgZmlsZXMgdG8gdGhlIGJhc2VVcmwgb2YgdGhlIG1hdGNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIG1vZHVsZS4gSWYgeW91IGhhdmUgYSBzY2VuYXJpbyBsaWtlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgbW9kdWxlQyBpcyBhIHZlcnNpb24gb2YgbW9kdWxlQiBpcyBhIHZlcnNpb24gb2YgbW9kdWxlQVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgVGhlbiwgbW9kdWxlQydzIGZpbGVzIGFyZSBhbGlhc2VkIHRvIHRoZSBiYXNlVXJsIG9mIG1vZHVsZUFcclxuXHJcbiAgICAgICMgICBpbmNsdWRlQWxpYXNlZEZpbGVzOiB0cnVlICAgICAgIyBJZiB0cnVlLCBhZGRzIHRoZSBhbGlhc2VkIGZpbGVzIHRvIHRoZSBtb2R1bGUncyBpbmNsdWRlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgYXJyYXksIGNhdXNpbmcgdGhlbSB0byBiZSBidWlsdCBpbnRvIHRoZSBmaW5hbCBtb2R1bGUuXHJcbiAgICAgICMgfV1cclxuICBcIlwiXCJcclxuXHJcbmV4cG9ydHMudmFsaWRhdGUgPSAoY29uZmlnLCB2YWxpZGF0b3JzKSAtPlxyXG4gIGVycm9ycyA9IFtdXHJcbiAgaWYgdmFsaWRhdG9ycy5pZkV4aXN0c0lzT2JqZWN0KGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlIGNvbmZpZ1wiLCBjb25maWcucmVxdWlyZUJ1aWxkQXV0b01vZHVsZSlcclxuICAgIHZhbGlkYXRvcnMuaWZFeGlzdHNJc0FycmF5T2ZTdHJpbmdzKGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBhdHRlcm5zXCIsIGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBhdHRlcm5zKVxyXG4gICAgdmFsaWRhdG9ycy5pZkV4aXN0c0ZpbGVFeGNsdWRlV2l0aFJlZ2V4QW5kU3RyaW5nKGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLmV4Y2x1ZGVcIiwgY29uZmlnLnJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUsIGNvbmZpZy53YXRjaC5jb21waWxlZERpcilcclxuICAgIHZhbGlkYXRvcnMuaWZFeGlzdHNJc0FycmF5T2ZTdHJpbmdzKGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLmRvbnRCdWlsZFwiLCBjb25maWcucmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5kb250QnVpbGQpXHJcbiAgICBpZiB2YWxpZGF0b3JzLmlmRXhpc3RzSXNBcnJheU9mT2JqZWN0cyhlcnJvcnMsIFwicmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5wbHVnaW5zXCIsIGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBsdWdpbnMpXHJcbiAgICAgIGZvciBwbHVnaW5Db25maWcgaW4gY29uZmlnLnJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUucGx1Z2luc1xyXG4gICAgICAgIHZhbGlkYXRvcnMuc3RyaW5nTXVzdEV4aXN0KGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBsdWdpbnMucGF0aFwiLCBwbHVnaW5Db25maWcucGF0aClcclxuICAgICAgICB2YWxpZGF0b3JzLmlzQXJyYXlPZlN0cmluZ3NNdXN0RXhpc3QoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUucGx1Z2lucy5wYXR0ZXJuc1wiLCBwbHVnaW5Db25maWcucGF0dGVybnMpXHJcbiAgICBpZiB2YWxpZGF0b3JzLmlmRXhpc3RzSXNBcnJheU9mT2JqZWN0cyhlcnJvcnMsIFwicmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5tb2R1bGVzXCIsIGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLm1vZHVsZXMpXHJcbiAgICAgIGZvciBtb2R1bGVDb25maWcgaW4gY29uZmlnLnJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUubW9kdWxlc1xyXG4gICAgICAgIHZhbGlkYXRvcnMuc3RyaW5nTXVzdEV4aXN0KGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLm1vZHVsZXMubmFtZVwiLCBtb2R1bGVDb25maWcubmFtZSlcclxuICAgICAgICB2YWxpZGF0b3JzLmlmRXhpc3RzSXNTdHJpbmcoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUubW9kdWxlcy5iYXNlVXJsXCIsIG1vZHVsZUNvbmZpZy5iYXNlVXJsKVxyXG4gICAgICAgIHZhbGlkYXRvcnMuaWZFeGlzdHNJc0FycmF5T2ZTdHJpbmdzKGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLm1vZHVsZXMuaW5jbHVkZVwiLCBtb2R1bGVDb25maWcuaW5jbHVkZSlcclxuICAgICAgICB1bmxlc3MgdmFsaWRhdG9ycy5pZkV4aXN0c0lzQXJyYXlPZlN0cmluZ3MoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUubW9kdWxlcy5wYXR0ZXJuc1wiLCBtb2R1bGVDb25maWcucGF0dGVybnMpXHJcbiAgICAgICAgICBpZiB2YWxpZGF0b3JzLmlzQXJyYXlPZlN0cmluZ3NNdXN0RXhpc3QoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUucGF0dGVybnNcIiwgY29uZmlnLnJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUucGF0dGVybnMpXHJcbiAgICAgICAgICAgIG1vZHVsZUNvbmZpZy5wYXR0ZXJucyA9IGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBhdHRlcm5zXHJcbiAgICAgICAgdW5sZXNzIHZhbGlkYXRvcnMuaWZFeGlzdHNGaWxlRXhjbHVkZVdpdGhSZWdleEFuZFN0cmluZyhlcnJvcnMsIFwicmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5tb2R1bGVzLmV4Y2x1ZGVcIiwgbW9kdWxlQ29uZmlnLCBjb25maWcud2F0Y2guY29tcGlsZWREaXIpXHJcbiAgICAgICAgICBtb2R1bGVDb25maWcuZXhjbHVkZSA9IGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLmV4Y2x1ZGVcclxuICAgICAgICBpZiB2YWxpZGF0b3JzLmlmRXhpc3RzSXNBcnJheU9mT2JqZWN0cyhlcnJvcnMsIFwicmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5tb2R1bGVzLnBsdWdpbnNcIiwgbW9kdWxlQ29uZmlnLnBsdWdpbnMpXHJcbiAgICAgICAgICBmb3IgcGx1Z2luQ29uZmlnIGluIG1vZHVsZUNvbmZpZy5wbHVnaW5zXHJcbiAgICAgICAgICAgIHZhbGlkYXRvcnMuc3RyaW5nTXVzdEV4aXN0KGVycm9ycywgXCJyZXF1aXJlQnVpbGRBdXRvTW9kdWxlLm1vZHVsZXMucGx1Z2lucy5wYXRoXCIsIHBsdWdpbkNvbmZpZy5wYXRoKVxyXG4gICAgICAgICAgICB2YWxpZGF0b3JzLmlzQXJyYXlPZlN0cmluZ3NNdXN0RXhpc3QoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUubW9kdWxlcy5wbHVnaW5zLnBhdHRlcm5zXCIsIHBsdWdpbkNvbmZpZy5wYXR0ZXJucylcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBtb2R1bGVDb25maWcucGx1Z2lucyA9IGNvbmZpZy5yZXF1aXJlQnVpbGRBdXRvTW9kdWxlLnBsdWdpbnNcclxuICAgICAgICB2YWxpZGF0b3JzLmlmRXhpc3RzSXNTdHJpbmcoZXJyb3JzLCBcInJlcXVpcmVCdWlsZEF1dG9Nb2R1bGUubW9kdWxlcy52ZXJzaW9uT2ZcIiwgbW9kdWxlQ29uZmlnLnZlcnNpb25PZilcclxuICAgICAgICB1bmxlc3MgdmFsaWRhdG9ycy5pZkV4aXN0c0lzQm9vbGVhbihlcnJvcnMsIFwicmVxdWlyZUJ1aWxkQXV0b01vZHVsZS5tb2R1bGVzLmluY2x1ZGVBbGlhc2VkRmlsZXNcIiwgbW9kdWxlQ29uZmlnLmluY2x1ZGVBbGlhc2VkRmlsZXMpXHJcbiAgICAgICAgICBtb2R1bGVDb25maWcuaW5jbHVkZUFsaWFzZWRGaWxlcyA9IHRydWVcclxuXHJcbiAgZXJyb3JzXHJcbiJdfQ==
